object i0 {
sealed trait i1
class i2 {
class i3 {
def unapply(i4: i1): AnyRef
}
trait i3 {
val i1: _;
var i3: Int = 0
var i2: i2[i1] = None
def i5: i1;
def i6: i7.i1
type i8; type i6 <: i6 }
def i7(i10: Int) = ???
def i10: Unit = { i7 = "" }
implicit main object i10 extends i8 with i5 {
type i9 = Stream[i6, i4]
val i10: i7.{ i3 => true }
}
val i11: i1 | Int : Int = null;
import i2.{ i2: i1, i2 < 22, i12, i15 }
trait i18 extends i4 with i8.i9(i9)
trait i5
type i9 = { type
sealed trait i1[i6]
trait i7[+i2, +i8]
@specialized i9 trait i10[-i2, -i6]
trait i7[i10 <: i4[i1, i5]]* (i1, i9 <: i12;
i9[this.type](i10, i2 => Any))
def flatMap[i9, i10](i10: => => i0[i9, i2]): Unit, i17]: i2 = 10 <[Comparable i10] def i14[i5](i13: i0[List, i8[type]]): Unit = {}
i7[Int]()
i6(true): i0[i1, i2] = i9(i4, 9)
def i17(): Unit
protected[this] final def i14[_, i4](i12: Int) = i10
}
class i1 Array def i2[i1, i9](i17: i7, i8: i6) {
def map[i9](i10: Array[i7]) = asInstanceOf[this.type]
}
object i13 {
def unapply[i2](i10: Boolean): Option[i0] = i10 match {
case i11(i1) => implicitly[Int] def i16[i15]: Any =
i4 match {
case i11[@Option(Int, _) =>
}
}