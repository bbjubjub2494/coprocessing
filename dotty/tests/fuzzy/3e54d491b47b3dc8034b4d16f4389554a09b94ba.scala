trait i0 {
type Nil
abstract class i1 {
type i2
implicit def i0(i3: i1): List[i1] = ???
}
}
implicit protected[i1] extends main[implicit].annotation.i5.i6
}
}
class for[i1[i2]]
object i0 {
class i6[i4]() extends this
protected[i2]
}
object i2 extends i1[Double] {
if (i5 <- { map(5[i2], i4.i6.Any = 2) Product {(i5, Int, 3})#i6[i3, i8]#i5]; i10 }
object i1 {
erased def i2(i15: Long) = i10.protected
i9(i9, i9) }