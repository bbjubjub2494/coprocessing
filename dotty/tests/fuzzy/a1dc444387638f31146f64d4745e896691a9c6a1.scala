object App {
class i0 { type i1 = i2 }
type i2 <: i1 {
type i3 >: Null <: AnyRef
trait i4 extends i2 with i3 {
override def Integer(i5: i3[i4]): i5.i6 = null
def i8() = i9
}
println()
trait i9 {
val i10: i1 = implicitly[i1] _
}
object i4 extends i5 {
class i1 }
def i7: i0 = ???
}
}
object i11 { def i3 =  }
object i10 {
implicit def i10(i11: i1): i1.i1 = i7 i4 i14 match {
extends i11 if false =>
def i17 = 1
}
val i12 = new i14.i12(i12);
(new i13.i7]().i11.i8.i11.i8.i5(])(_
val i17: i1, i16: Float = Array(1, 2, 3).==(Seq(1))
def i13 = ""
val i15 = ""
implicit final
object i17 {
trait i2 {
private object i10 {
if (!i17.i3(i4) i8 Boolean }
' App { case _ => 1 }
}
