class i0 {
type Ordering[i1, i2] = (=> i3[i1])
def i4[i2, i3](i5: i1): i4[Any]
i8 += i14 {
type i4[+i9] = i5
def i7: Int = i6(5)
class i9[i10 <: i16 <: i4[_], i12](val i14: i11[_], i4: i11) {
def i16[i14 >: i1]: i0 = ???
implicit def i13[i4](i5: (=> i6)): i1[i6]
type i13[i7] = i13[i7]
def i8[+i1[+i2] <: i0[i1]]](i9: => ii5[i7]): i7[i5] = sys.error();
def i10(i11: i4[i10.i4])(implicit i8: i0[i6#i0]) = i4 * i7 i5 i4! this match {
case i14(i9) => 3 }
}
class i10 {
type i13 = i10.i8
val i11 =
var i21 =
case class Tuple1(i3: i1, i4: i4, i6)
}
(new i10(i13))
}
}
package i1.i0
object i12 {
def i9(i10: i1)(implicit i9: i8[Boolean]) = implicitly[i9](i10: Any, i4, i9) {}
case class i9[i14[i2]](i16: i11[i8[i2]]) extends i10[i4, i14] {
def this(i11: i12) = {
val i5 = new i5[Int, Int]
}
}
